<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WAR TANK: ELITE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Cairo:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            font-family: 'Cairo', sans-serif;
            touch-action: none;
            user-select: none;
        }

        /* ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù„Ø¹Ø¨ */
        #game-layer { position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }

        /* Ø§Ù„Ø´Ø§Ø´Ø§Øª */
        .screen {
            position: absolute; inset: 0; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(10px);
            z-index: 20;
            transition: opacity 0.5s;
        }
        
        .hidden { opacity: 0; pointer-events: none; }
        .gone { display: none !important; }

        /* Ù†ØµÙˆØµ ÙˆØ£Ø²Ø±Ø§Ø± */
        h1 { font-family: 'Black Ops One', cursive; color: #eab308; text-shadow: 0 0 20px rgba(234, 179, 8, 0.5); letter-spacing: 2px; }
        
        .btn {
            background: linear-gradient(45deg, #2563eb, #1d4ed8);
            border: 2px solid #60a5fa;
            color: white;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(37, 99, 235, 0.4);
            pointer-events: auto;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(37, 99, 235, 0.6); }
        .btn:active { transform: scale(0.95); }

        .input-field {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 12px 20px;
            color: white;
            font-size: 1.1rem;
            text-align: center;
            border-radius: 4px;
            width: 300px;
            margin-bottom: 20px;
            font-family: monospace;
            pointer-events: auto;
        }

        /* Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø¬ÙˆØ§Ù„ */
        .joystick-area {
            position: absolute; bottom: 40px; left: 40px; width: 150px; height: 150px;
            background: rgba(255,255,255,0.05); border-radius: 50%; border: 2px solid rgba(255,255,255,0.1);
            pointer-events: auto; display: none;
        }
        .fire-btn-mobile {
            position: absolute; bottom: 50px; right: 50px; width: 100px; height: 100px;
            background: rgba(220, 38, 38, 0.5); border-radius: 50%; border: 4px solid rgba(255,255,255,0.2);
            pointer-events: auto; display: none; display: flex; justify-content: center; align-items: center;
        }
        
        @media (max-width: 1024px) {
            .joystick-area, .fire-btn-mobile { display: flex !important; }
        }

        /* HUD */
        .hud-panel {
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>

    <!-- Game Layer -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Layer -->
    <div id="ui-layer">
        <!-- Top HUD -->
        <div class="absolute top-4 left-4 right-4 flex justify-between items-start">
            <!-- Player Info -->
            <div class="hud-panel flex flex-col gap-1">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-blue-500 shadow-[0_0_10px_#3b82f6]"></div>
                    <span class="font-bold text-blue-400 text-lg">ÙØ±ÙŠÙ‚Ùƒ</span>
                </div>
                <div class="w-48 h-4 bg-gray-800 rounded overflow-hidden border border-gray-600 relative">
                    <div id="hp-bar" class="h-full bg-gradient-to-r from-blue-600 to-blue-400 transition-all duration-300" style="width: 100%"></div>
                </div>
                <div id="buffs-container" class="flex gap-2 h-8 mt-1"></div>
            </div>

            <!-- Score -->
            <div class="hud-panel">
                <span class="text-2xl font-black text-white tracking-widest" id="score-display">0 - 0</span>
            </div>

            <!-- Enemy Info -->
            <div class="hud-panel flex flex-col items-end gap-1">
                <div class="flex items-center gap-2">
                    <span class="font-bold text-red-400 text-lg">Ø§Ù„Ø¹Ø¯Ùˆ</span>
                    <div class="w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_#ef4444]"></div>
                </div>
                <div class="w-48 h-4 bg-gray-800 rounded overflow-hidden border border-gray-600">
                    <div id="enemy-hp-bar" class="h-full bg-gradient-to-l from-red-600 to-red-400 transition-all duration-300" style="width: 100%"></div>
                </div>
                <div id="enemy-buffs-container" class="flex gap-2 h-8 mt-1 justify-end"></div>
            </div>
        </div>

        <!-- Reload Indicator -->
        <div id="reload-indicator" class="absolute bottom-10 left-1/2 -translate-x-1/2 w-12 h-12 rounded-full border-4 border-gray-600 flex items-center justify-center hidden">
            <div class="w-full h-full bg-white/20 rounded-full animate-ping"></div>
        </div>
        
        <!-- Mobile Controls -->
        <div id="joystick" class="joystick-area">
            <div id="stick" class="w-16 h-16 bg-white/20 rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 shadow-inner backdrop-blur"></div>
        </div>
        <div id="fire-btn" class="fire-btn-mobile active:scale-95 transition-transform">
            <img src="https://cdn-icons-png.flaticon.com/512/1041/1041886.png" class="w-10 h-10 invert opacity-80">
        </div>
    </div>

    <!-- Lobby Screen -->
    <div id="lobby-screen" class="screen">
        <h1 class="text-6xl mb-2">WAR TANK</h1>
        <p class="text-yellow-500 mb-12 text-xl font-bold tracking-widest">BATTLEFIELD ELITE</p>
        
        <div id="loading-state" class="flex flex-col items-center">
            <div class="w-12 h-12 border-4 border-yellow-500 border-t-transparent rounded-full animate-spin mb-4"></div>
            <p class="text-gray-400">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…...</p>
        </div>

        <div id="menu-state" class="hidden flex flex-col items-center w-full max-w-md gap-4">
            <button id="btn-create" class="btn w-full">Ø¥Ù†Ø´Ø§Ø¡ ØºØ±ÙØ© Ù…Ø¹Ø±ÙƒØ©</button>
            
            <div class="flex items-center w-full gap-4 my-2">
                <div class="h-px bg-gray-700 flex-1"></div>
                <span class="text-gray-500 font-bold">Ø£Ùˆ</span>
                <div class="h-px bg-gray-700 flex-1"></div>
            </div>

            <div class="flex w-full gap-2">
                <input type="text" id="room-code-input" placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„ØºØ±ÙØ©" class="input-field flex-1 mb-0">
                <button id="btn-join" class="btn" style="background: #374151; border-color: #4b5563;">Ø§Ù†Ø¶Ù…Ø§Ù…</button>
            </div>
        </div>

        <div id="waiting-state" class="hidden flex flex-col items-center bg-gray-900/80 p-8 rounded-xl border border-gray-700">
            <p class="text-gray-400 mb-2">ÙƒÙˆØ¯ Ø§Ù„ØºØ±ÙØ©</p>
            <div id="room-code-display" class="text-5xl font-mono font-bold text-white mb-6 tracking-widest select-all cursor-pointer bg-black/50 px-6 py-2 rounded">---</div>
            <div class="flex items-center gap-3">
                <span class="animate-ping w-3 h-3 bg-green-500 rounded-full"></span>
                <span class="text-green-400 font-bold">Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø®ØµÙ…...</span>
            </div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden gone">
        <h2 id="end-title" class="text-8xl font-black mb-4 uppercase drop-shadow-2xl">VICTORY</h2>
        <p id="end-desc" class="text-2xl text-gray-300 mb-8">ØªÙ… ØªØ¯Ù…ÙŠØ± Ø§Ù„Ø¹Ø¯Ùˆ</p>
        <button onclick="location.reload()" class="btn">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©</button>
    </div>

    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, updateDoc, arrayUnion, arrayRemove, serverTimestamp, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyD6MRZ7d7J1333erYoBrUGqocJNdGNjB7w",
            authDomain: "neew-aec2b.firebaseapp.com",
            databaseURL: "https://neew-aec2b-default-rtdb.firebaseio.com",
            projectId: "neew-aec2b",
            storageBucket: "neew-aec2b.firebasestorage.app",
            messagingSenderId: "70112873200",
            appId: "1:70112873200:web:b8ef2b3863be6f1bf39035"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';

        // --- Assets ---
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØµÙˆØ± Ø§Ù„ØªÙŠ Ø·Ù„Ø¨Ù‡Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const TANK_BLUE = new Image(); TANK_BLUE.src = 'https://images.vexels.com/media/users/3/195072/isolated/preview/83ecf27618ee1c6aecfee2c41dc8003c-military-tank-side-view.png';
        const TANK_RED = new Image(); TANK_RED.src = 'https://images.vexels.com/media/users/3/256747/isolated/preview/fb1eff9ab5744e1044bb495dfea4956b-military-tank-color-stroke.png';
        const IMG_CRATE = new Image(); IMG_CRATE.src = 'https://cdn-icons-png.flaticon.com/512/9332/9332857.png'; // ØµÙ†Ø¯ÙˆÙ‚ Ø®Ø´Ø¨ÙŠ
        const IMG_WALL = new Image(); IMG_WALL.src = 'https://cdn-icons-png.flaticon.com/512/8652/8652575.png'; // Ø¬Ø¯Ø§Ø± Ø­Ø¬Ø±ÙŠ
        
        // ØµÙˆØª Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù…Ø®ØµØµ
        const SND_SHOOT = new Audio('https://www.dropbox.com/scl/fi/wii8v05g54cl48d830rqd/072807_heavy-machine-gun-50-caliber-39765-mp3cut.net.mp3?rlkey=pj4w6rn3oq1evy6x0lcztvvez&st=we408v48&dl=1');
        
        // --- Game Config ---
        const WORLD_W = 2000;
        const WORLD_H = 2000;
        const CAM_W = window.innerWidth;
        const CAM_H = window.innerHeight;
        
        // --- State ---
        let me = { id: null, x: 0, y: 0, angle: 0, hp: 100, team: 'blue', buffs: [] };
        let enemy = { id: null, x: 0, y: 0, angle: 0, hp: 100, team: 'red', buffs: [] };
        let bullets = [];
        let particles = [];
        let walls = [];
        let powerups = [];
        let camera = { x: 0, y: 0 };
        let screenShake = 0;
        let gameActive = false;
        let isHost = false;
        let roomId = null;

        // --- Inputs ---
        const keys = {};
        const mouse = { x: 0, y: 0, down: false };
        const stick = { active: false, x: 0, y: 0 };

        // --- Initialization ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.onresize = resize;
        resize();

        // --- Map Generation (Procedural) ---
        function generateMap() {
            const newWalls = [];
            // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
            newWalls.push({x: -50, y: -50, w: WORLD_W+100, h: 50}); // Top
            newWalls.push({x: -50, y: WORLD_H, w: WORLD_W+100, h: 50}); // Bottom
            newWalls.push({x: -50, y: 0, w: 50, h: WORLD_H}); // Left
            newWalls.push({x: WORLD_W, y: 0, w: 50, h: WORLD_H}); // Right

            // Ø¹ÙˆØ§Ø¦Ù‚ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© (Grid Based to keep it playable)
            const gridSize = 200;
            for(let x=200; x<WORLD_W-200; x+=gridSize) {
                for(let y=200; y<WORLD_H-200; y+=gridSize) {
                    if(Math.random() < 0.3) {
                        const type = Math.random() > 0.5 ? 'crate' : 'wall';
                        const size = type === 'crate' ? 60 : 100;
                        // ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… Ø§Ù„Ø¨Ù†Ø§Ø¡ ÙÙˆÙ‚ Ù†Ù‚Ø§Ø· Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
                        if(Math.abs(x - 200) < 300 && Math.abs(y - WORLD_H/2) < 300) continue;
                        if(Math.abs(x - (WORLD_W-200)) < 300 && Math.abs(y - WORLD_H/2) < 300) continue;
                        
                        newWalls.push({
                            x: x + Math.random()*50, 
                            y: y + Math.random()*50, 
                            w: size, h: size, 
                            type: type
                        });
                    }
                }
            }
            return newWalls;
        }

        // --- Core Game Loop ---
        function loop() {
            if(!gameActive) return;

            update();
            draw();
            requestAnimationFrame(loop);
        }

        let lastFire = 0;
        let lastSync = 0;

        function update() {
            if(screenShake > 0) screenShake *= 0.9;

            // 1. Movement Logic (Physics)
            let dx = 0, dy = 0;
            if(keys['w'] || keys['ArrowUp']) dy = -1;
            if(keys['s'] || keys['ArrowDown']) dy = 1;
            if(keys['a'] || keys['ArrowLeft']) dx = -1;
            if(keys['d'] || keys['ArrowRight']) dx = 1;
            
            if(stick.active) { dx = stick.x; dy = stick.y; }

            // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ù…ØªØ¬Ù‡ (Normalize)
            if(dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx*dx + dy*dy);
                dx /= len; dy /= len;
                
                const speed = me.buffs.includes('SPEED') ? 8 : 5;
                
                // Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯
                const nextX = me.x + dx * speed;
                const nextY = me.y + dy * speed;
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØµØ§Ø¯Ù… Ù…Ø¹ Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
                if(!checkWallCollision(nextX, me.y)) me.x = nextX;
                if(!checkWallCollision(me.x, nextY)) me.y = nextY;

                // Ø¥Ù†Ø´Ø§Ø¡ Ø¢Ø«Ø§Ø±
                if(Math.random() < 0.2) {
                    particles.push({
                        type: 'track', x: me.x, y: me.y, angle: me.angle, life: 100, alpha: 0.6
                    });
                }
            }

            // 2. Aiming Logic
            if(stick.active && (Math.abs(stick.x) > 0.1 || Math.abs(stick.y) > 0.1)) {
                // Ù„Ù„Ø¬ÙˆØ§Ù„: Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ù…Ø¹ Ø§Ù„Ø­Ø±ÙƒØ©
                me.angle = Math.atan2(stick.y, stick.x);
            } else {
                // Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±: Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ù†Ø­Ùˆ Ø§Ù„Ù…Ø§ÙˆØ³
                // Ù†Ø­ØªØ§Ø¬ ØªØ­ÙˆÙŠÙ„ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù…Ø§ÙˆØ³ (Ø´Ø§Ø´Ø©) Ø¥Ù„Ù‰ Ø¹Ø§Ù„Ù… (World)
                const worldMouseX = mouse.x + camera.x;
                const worldMouseY = mouse.y + camera.y;
                me.angle = Math.atan2(worldMouseY - me.y, worldMouseX - me.x);
            }

            // 3. Camera Follow (Smooth)
            // Ø§Ù„Ù‡Ø¯Ù: ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙ
            const targetCamX = me.x - canvas.width / 2;
            const targetCamY = me.y - canvas.height / 2;
            camera.x += (targetCamX - camera.x) * 0.1;
            camera.y += (targetCamY - camera.y) * 0.1;
            
            // ØªØ«Ø¨ÙŠØª Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¹Ø§Ù„Ù…
            camera.x = Math.max(0, Math.min(camera.x, WORLD_W - canvas.width));
            camera.y = Math.max(0, Math.min(camera.y, WORLD_H - canvas.height));

            // 4. Shooting
            const now = Date.now();
            const fireRate = me.buffs.includes('RAPID') ? 200 : 500;
            if((mouse.down || keys[' ']) && now - lastFire > fireRate) {
                shoot();
                lastFire = now;
            }

            // 5. Interpolate Enemy
            enemy.x += (enemy.targetX - enemy.x || 0) * 0.1;
            enemy.y += (enemy.targetY - enemy.y || 0) * 0.1;
            // Angle interpolation tricky due to wrap, just snap for now
            enemy.angle = enemy.targetAngle || 0;

            // 6. Update Bullets
            updateBullets();
            updateParticles();

            // 7. Sync
            if(now - lastSync > 50) {
                sync();
                lastSync = now;
            }
        }

        function checkWallCollision(x, y) {
            const r = 30; // Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ø¯Ø¨Ø§Ø¨Ø©
            for(let w of walls) {
                // AABB vs Circle (Simplified to Rect vs Rect for speed)
                if(x + r > w.x && x - r < w.x + w.w &&
                   y + r > w.y && y - r < w.y + w.h) {
                    return true;
                }
            }
            return false;
        }

        function updateBullets() {
            for(let i=bullets.length-1; i>=0; i--) {
                const b = bullets[i];
                b.x += b.vx;
                b.y += b.vy;

                // Ø°ÙŠÙ„ Ø§Ù„Ø±ØµØ§ØµØ©
                particles.push({type: 'glow', x: b.x, y: b.y, color: '#fcd34d', life: 5, size: 4});

                // ØªØµØ§Ø¯Ù… Ù…Ø¹ Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
                let hitWall = false;
                for(let w of walls) {
                    if(b.x > w.x && b.x < w.x + w.w && b.y > w.y && b.y < w.y + w.h) {
                        hitWall = true;
                        // ØªØ£Ø«ÙŠØ± Ø§ØµØ·Ø¯Ø§Ù…
                        createExplosion(b.x, b.y, '#9ca3af', 8); // Ø±Ù…Ø§Ø¯ÙŠ Ù„Ù„Ø¬Ø¯Ø±Ø§Ù†
                        break;
                    }
                }
                
                if(hitWall || b.x < 0 || b.x > WORLD_W || b.y < 0 || b.y > WORLD_H) {
                    bullets.splice(i, 1);
                    continue;
                }

                // ØªØµØ§Ø¯Ù… Ù…Ø¹ Ø§Ù„Ø¹Ø¯Ùˆ (Ø£Ù†Ø§ Ø£Ø­Ø³Ø¨ Ø¥ØµØ§Ø¨Ø§ØªÙŠ Ù„Ù„Ø¹Ø¯Ùˆ)
                if(b.owner === me.id) {
                    const dist = Math.hypot(b.x - enemy.x, b.y - enemy.y);
                    if(dist < 35) {
                        bullets.splice(i, 1);
                        createExplosion(enemy.x, enemy.y, '#ef4444', 15); // Ø£Ø­Ù…Ø± Ù„Ù„Ø¯Ù…
                        
                        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¶Ø±Ø±
                        if(!enemy.buffs.includes('SHIELD')) {
                            const dmg = 10;
                            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¶Ø±Ø± ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ±
                            damageEnemy(dmg);
                        } else {
                            createExplosion(enemy.x, enemy.y, '#3b82f6', 10); // Ø¯Ø±Ø¹ Ø£Ø²Ø±Ù‚
                        }
                    }
                } 
                // Ø¨ØµØ±ÙŠØ§Ù‹: Ø±ØµØ§ØµØ© Ø§Ù„Ø¹Ø¯Ùˆ ØªØµÙŠØ¨Ù†ÙŠ
                else if(b.owner !== me.id) {
                    const dist = Math.hypot(b.x - me.x, b.y - me.y);
                    if(dist < 35) {
                        bullets.splice(i, 1);
                        createExplosion(me.x, me.y, me.buffs.includes('SHIELD') ? '#3b82f6' : '#ef4444', 10);
                    }
                }
            }
        }

        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                if(p.type === 'track') {
                    p.life--;
                    if(p.life <= 0) particles.splice(i, 1);
                } else {
                    p.x += (p.vx || 0);
                    p.y += (p.vy || 0);
                    p.life--;
                    if(p.life <= 0) particles.splice(i, 1);
                }
            }

            // Powerups
            powerups.forEach(p => {
                if(Math.hypot(me.x - p.x, me.y - p.y) < 50) {
                    collectPowerup(p);
                }
            });
        }

        // --- Drawing ---
        function draw() {
            // Clear Screen
            ctx.fillStyle = '#18181b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Camera Shake
            const shakeX = (Math.random()-0.5) * screenShake;
            const shakeY = (Math.random()-0.5) * screenShake;

            ctx.save();
            ctx.translate(-camera.x + shakeX, -camera.y + shakeY);

            // 1. Grid Floor
            ctx.strokeStyle = '#27272a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const gridSize = 100;
            // Optimize: Draw only visible grid
            const startX = Math.floor(camera.x / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize;
            for(let x=startX; x<camera.x+canvas.width; x+=gridSize) {
                ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y+canvas.height);
            }
            for(let y=startY; y<camera.y+canvas.height; y+=gridSize) {
                ctx.moveTo(camera.x, y); ctx.lineTo(camera.x+canvas.width, y);
            }
            ctx.stroke();

            // 2. Tracks (Under tanks)
            particles.forEach(p => {
                if(p.type === 'track') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.angle);
                    ctx.fillStyle = `rgba(0,0,0,${p.alpha * (p.life/100)})`;
                    ctx.fillRect(-35, -20, 15, 40);
                    ctx.fillRect(20, -20, 15, 40);
                    ctx.restore();
                }
            });

            // 3. Walls
            ctx.fillStyle = '#3f3f46';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            walls.forEach(w => {
                // Ø§Ù„Ø¸Ù„
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(w.x+10, w.y+10, w.w, w.h);
                
                // Ø§Ù„Ø¬Ø³Ù…
                if(w.type === 'crate') {
                    ctx.drawImage(IMG_CRATE, w.x, w.y, w.w, w.h);
                } else if(w.type === 'wall') {
                    ctx.fillStyle = '#52525b';
                    ctx.fillRect(w.x, w.y, w.w, w.h);
                    ctx.strokeRect(w.x, w.y, w.w, w.h);
                    // ØªÙØ§ØµÙŠÙ„ Ø¨Ø³ÙŠØ·Ø©
                    ctx.fillStyle = '#3f3f46';
                    ctx.fillRect(w.x+5, w.y+5, w.w-10, w.h-10);
                } else {
                    // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù…
                    ctx.fillStyle = '#18181b';
                    ctx.fillRect(w.x, w.y, w.w, w.h);
                }
            });

            // 4. Powerups
            powerups.forEach(p => {
                const bob = Math.sin(Date.now()/300) * 10;
                ctx.save();
                ctx.translate(p.x, p.y + bob);
                
                // Ù‡Ø§Ù„Ø©
                ctx.shadowBlur = 20;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI*2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(p.icon, 0, 7);
                ctx.restore();
            });

            // 5. Tanks
            drawTank(me, me.team === 'blue' ? TANK_BLUE : TANK_RED, true);
            drawTank(enemy, enemy.team === 'blue' ? TANK_BLUE : TANK_RED, false);

            // 6. Bullets
            bullets.forEach(b => {
                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(Math.atan2(b.vy, b.vx));
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#fbbf24';
                ctx.fillStyle = '#fffbeb';
                
                // Ø´ÙƒÙ„ Ø§Ù„Ø±ØµØ§ØµØ©
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(-10, 5);
                ctx.lineTo(-10, -5);
                ctx.fill();
                
                ctx.restore();
            });

            // 7. Explosion Particles
            particles.forEach(p => {
                if(p.type !== 'track' && p.type !== 'glow') {
                    ctx.globalAlpha = p.life / 20;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            });

            ctx.restore();
        }

        function drawTank(t, img, isLocal) {
            ctx.save();
            ctx.translate(t.x, t.y);
            
            // Ø§Ù„Ø¯Ø±Ø¹
            if(t.buffs && t.buffs.includes('SHIELD')) {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#3b82f6';
                ctx.beginPath();
                ctx.arc(0, 0, 60, 0, Math.PI*2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Ø§Ù„Ø¯ÙˆØ±Ø§Ù†
            ctx.rotate(t.angle + Math.PI); // ØªØµØ­ÙŠØ­ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ØµÙˆØ±Ø©

            // Ø§Ù„Ø¸Ù„
            ctx.shadowColor = 'rgba(0,0,0,0.6)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetY = 10;

            try {
                ctx.drawImage(img, -50, -50, 100, 100);
            } catch(e) {}

            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            // Ø´Ø±ÙŠØ· Ø§Ù„ØµØ­Ø© ÙÙˆÙ‚ Ø§Ù„Ø¯Ø¨Ø§Ø¨Ø© (Ù„Ù„Ø¹Ø¯Ùˆ ÙÙ‚Ø·)
            if(!isLocal) {
                ctx.rotate(-(t.angle + Math.PI));
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(-30, -70, 60, 8);
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(-28, -68, 56 * (t.hp/100), 4);
            }

            ctx.restore();
        }

        // --- Logic Helpers ---

        function shoot() {
            const isDouble = me.buffs.includes('DOUBLE');
            const type = isDouble ? 'double' : 'normal';
            const shotId = `${me.id}_${Date.now()}`;
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­Ù„ÙŠ
            spawnBullet(me.x, me.y, me.angle, me.id, type);
            
            // Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ø´Ø¨ÙƒØ©
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${roomId}`);
            updateDoc(ref, {
                lastShot: {
                    id: shotId,
                    shooter: me.id,
                    x: me.x, y: me.y, angle: me.angle, type: type,
                    ts: serverTimestamp()
                }
            });

            // Recoil Visual
            me.x -= Math.cos(me.angle) * 5;
            me.y -= Math.sin(me.angle) * 5;
            screenShake = 10;
        }

        function spawnBullet(x, y, angle, owner, type) {
            const speed = 25;
            const offset = 60; // ÙÙˆÙ‡Ø© Ø§Ù„Ù…Ø¯ÙØ¹

            const add = (angOffset, sideOffset) => {
                // Ø­Ø³Ø§Ø¨ Ù…ÙˆÙ‚Ø¹ Ø§Ù„ÙÙˆÙ‡Ø© Ø¨Ø¯Ù‚Ø©
                const forwardX = Math.cos(angle) * offset;
                const forwardY = Math.sin(angle) * offset;
                const sideX = Math.cos(angle + Math.PI/2) * sideOffset;
                const sideY = Math.sin(angle + Math.PI/2) * sideOffset;

                bullets.push({
                    x: x + forwardX + sideX,
                    y: y + forwardY + sideY,
                    vx: Math.cos(angle + angOffset) * speed,
                    vy: Math.sin(angle + angOffset) * speed,
                    owner: owner
                });
                
                // Muzzle Flash
                createExplosion(x + forwardX + sideX, y + forwardY + sideY, '#fcd34d', 5);
            };

            if(type === 'double') {
                add(0, -10); add(0, 10);
            } else {
                add(0, 0);
            }

            // Play Sound (Cloned to overlap)
            const s = SND_SHOOT.cloneNode();
            s.volume = 0.4;
            s.play().catch(()=>{});
        }

        function createExplosion(x, y, color, count) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15,
                    life: 20 + Math.random()*10,
                    color: color,
                    size: Math.random()*5 + 2
                });
            }
        }

        function damageEnemy(amount) {
            const newHp = Math.max(0, enemy.hp - amount);
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${roomId}`);
            updateDoc(ref, {
                [`players.${enemy.id}.hp`]: newHp
            });
        }

        async function collectPowerup(p) {
            // ØªØ£Ø«ÙŠØ± ØµÙˆØªÙŠ Ø¨Ø³ÙŠØ·
            const osc = (new (window.AudioContext||window.webkitAudioContext)).createOscillator();
            const g = osc.context.createGain();
            osc.connect(g); g.connect(osc.context.destination);
            osc.frequency.value = 600; 
            osc.start(); osc.stop(osc.context.currentTime+0.1);

            powerups = powerups.filter(pu => pu.id !== p.id);
            
            if(p.type === 'REPAIR') {
                me.hp = Math.min(100, me.hp + 30);
            } else {
                if(!me.buffs.includes(p.type)) {
                    me.buffs.push(p.type);
                    updateBuffsUI();
                    setTimeout(() => {
                        me.buffs = me.buffs.filter(b => b !== p.type);
                        updateBuffsUI();
                    }, 5000); // 5 seconds
                }
            }

            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${roomId}`);
            await updateDoc(ref, { powerups: arrayRemove(p) });
        }

        function updateBuffsUI() {
            const container = document.getElementById('buffs-container');
            container.innerHTML = me.buffs.map(b => {
                const colors = { SPEED: '#fbbf24', DOUBLE: '#a855f7', SHIELD: '#3b82f6', RAPID: '#ef4444' };
                const icons = { SPEED: 'âš¡', DOUBLE: 'ğŸš€', SHIELD: 'ğŸ›¡ï¸', RAPID: 'ğŸ”¥' };
                return `<div class="w-8 h-8 rounded bg-gray-900 border border-[${colors[b]}] flex items-center justify-center text-lg">${icons[b]}</div>`;
            }).join('');
        }

        // --- Firebase Sync ---
        async function sync() {
            if(!roomId) return;
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${roomId}`);
            await updateDoc(ref, {
                [`players.${me.id}.x`]: Math.round(me.x),
                [`players.${me.id}.y`]: Math.round(me.y),
                [`players.${me.id}.angle`]: parseFloat(me.angle.toFixed(3)),
                [`players.${me.id}.buffs`]: me.buffs,
                [`players.${me.id}.hp`]: me.hp // Sync HP back for safety
            });
        }

        function startListening(ref) {
            onSnapshot(ref, (snap) => {
                const data = snap.data();
                if(!data) return;

                // Players
                Object.keys(data.players).forEach(pid => {
                    if(pid !== me.id) {
                        const p = data.players[pid];
                        enemy.id = pid;
                        enemy.targetX = p.x; enemy.targetY = p.y; enemy.targetAngle = p.angle;
                        enemy.hp = p.hp; enemy.buffs = p.buffs || [];
                        enemy.team = p.team;
                        
                        // Update Enemy UI
                        document.getElementById('enemy-hp-bar').style.width = enemy.hp + '%';
                    } else {
                        // My HP (Server authority somewhat)
                        if(data.players[pid].hp < me.hp) {
                            me.hp = data.players[pid].hp;
                            screenShake = 20; // Hit effect
                        }
                    }
                });
                
                // My UI
                document.getElementById('hp-bar').style.width = me.hp + '%';

                // Bullets
                if(data.lastShot && data.lastShot.id !== window.lastShotId && data.lastShot.shooter !== me.id) {
                    window.lastShotId = data.lastShot.id;
                    spawnBullet(data.lastShot.x, data.lastShot.y, data.lastShot.angle, data.lastShot.shooter, data.lastShot.type);
                }

                // Powerups
                powerups = (data.powerups || []).map(p => ({
                    ...p, 
                    color: p.type === 'REPAIR' ? '#22c55e' : (p.type === 'SHIELD' ? '#3b82f6' : '#eab308'),
                    icon: p.type === 'REPAIR' ? 'ğŸ”§' : 'â˜…'
                }));

                // Win/Loss
                if(me.hp <= 0 || enemy.hp <= 0) {
                    gameActive = false;
                    document.getElementById('ui-layer').classList.add('hidden');
                    document.getElementById('game-over-screen').classList.remove('hidden', 'gone');
                    if(me.hp > 0) {
                        document.getElementById('end-title').innerText = "VICTORY";
                        document.getElementById('end-title').className = "text-8xl font-black mb-4 uppercase drop-shadow-2xl text-yellow-500";
                    } else {
                        document.getElementById('end-title').innerText = "DEFEAT";
                        document.getElementById('end-title').className = "text-8xl font-black mb-4 uppercase drop-shadow-2xl text-gray-500";
                    }
                }
            });
        }

        // --- Room Management ---
        document.getElementById('btn-create').onclick = async () => {
            document.getElementById('menu-state').classList.add('hidden');
            document.getElementById('waiting-state').classList.remove('hidden');
            
            roomId = Math.random().toString(36).substring(2, 7).toUpperCase();
            isHost = true;
            document.getElementById('room-code-display').innerText = roomId;
            
            // Generate Walls
            walls = generateMap();
            
            me.x = 200; me.y = WORLD_H/2; me.team = 'blue';

            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${roomId}`);
            await setDoc(ref, {
                status: 'waiting',
                map: walls, // Sync Map!
                players: {
                    [me.id]: { x: me.x, y: me.y, hp: 100, team: 'blue' }
                }
            });

            onSnapshot(ref, (snap) => {
                const d = snap.data();
                if(d && d.status === 'playing' && !gameActive) {
                    startGame();
                }
            });

            // Start Spawner
            setInterval(async () => {
                if(!gameActive) return;
                if(powerups.length < 5) {
                    const types = ['SPEED', 'DOUBLE', 'SHIELD', 'RAPID', 'REPAIR'];
                    const type = types[Math.floor(Math.random()*types.length)];
                    const p = {
                        id: Date.now() + Math.random(),
                        x: 200 + Math.random()*(WORLD_W-400),
                        y: 200 + Math.random()*(WORLD_H-400),
                        type: type
                    };
                    await updateDoc(ref, { powerups: arrayUnion(p) });
                }
            }, 5000);
        };

        document.getElementById('btn-join').onclick = async () => {
            const code = document.getElementById('room-code-input').value.toUpperCase();
            if(!code) return;
            roomId = code;
            
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${roomId}`);
            const snap = await getDoc(ref);
            if(snap.exists() && snap.data().status === 'waiting') {
                walls = snap.data().map || []; // Load Host's Map
                me.x = WORLD_W - 200; me.y = WORLD_H/2; me.team = 'red'; me.angle = Math.PI;
                
                await updateDoc(ref, {
                    [`players.${me.id}`]: { x: me.x, y: me.y, hp: 100, team: 'red', angle: Math.PI },
                    status: 'playing'
                });
                startGame();
                startListening(ref);
            } else {
                alert("ØºØ±ÙØ© ØºÙŠØ± ØµØ§Ù„Ø­Ø©");
            }
        };

        function startGame() {
            document.getElementById('lobby-screen').style.opacity = 0;
            setTimeout(() => document.getElementById('lobby-screen').classList.add('gone'), 500);
            gameActive = true;
            loop();
            // Host also needs to listen after start
            if(isHost) startListening(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${roomId}`));
        }

        // --- Init Auth ---
        try {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await auth.signInWithCustomToken(__initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        } catch (e) { await signInAnonymously(auth); }

        onAuthStateChanged(auth, u => {
            if(u) {
                me.id = u.uid;
                document.getElementById('loading-state').classList.add('hidden');
                document.getElementById('menu-state').classList.remove('hidden');
            }
        });

        // --- Input Listeners ---
        window.onkeydown = e => keys[e.key] = true;
        window.onkeyup = e => keys[e.key] = false;
        window.onmousemove = e => { mouse.x = e.clientX; mouse.y = e.clientY; };
        window.onmousedown = () => mouse.down = true;
        window.onmouseup = () => mouse.down = false;
        
        // Touch
        const joy = document.getElementById('joystick');
        const knob = document.getElementById('stick');
        let joyStart = {x:0, y:0};
        
        joy.ontouchstart = e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            joyStart = {x: t.clientX, y: t.clientY};
            stick.active = true;
        };
        joy.ontouchmove = e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            const dx = t.clientX - joyStart.x;
            const dy = t.clientY - joyStart.y;
            const dist = Math.min(50, Math.hypot(dx, dy));
            const ang = Math.atan2(dy, dx);
            stick.x = Math.cos(ang); stick.y = Math.sin(ang);
            knob.style.transform = `translate(${stick.x*dist}px, ${stick.y*dist}px)`;
        };
        joy.ontouchend = () => {
            stick.active = false; stick.x = 0; stick.y = 0;
            knob.style.transform = `translate(-50%, -50%)`; // Reset to center (CSS handles center via translate)
             knob.style.transform = `translate(0px, 0px)`;
        };
        
        document.getElementById('fire-btn').ontouchstart = (e) => {
            e.preventDefault();
            mouse.down = true;
        };
        document.getElementById('fire-btn').ontouchend = () => mouse.down = false;

    </script>
</body>
</html>
