<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ù…Ø¹Ø±ÙƒØ© Ø§Ù„Ø£Ø³Ù‡Ù…: Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap');
        
        body {
            font-family: 'Cairo', sans-serif;
            overflow: hidden;
            background-color: #0f172a;
            color: white;
            touch-action: none; /* Ù„Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ¨ÙŠØ± Ø¨Ø§Ù„Ø³Ø­Ø¨ Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„ */
        }

        #gameCanvas {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            border-radius: 8px;
            cursor: crosshair;
        }

        .ui-panel {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .health-bar-container {
            width: 200px;
            height: 20px;
            background: #334155;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #1e293b;
        }

        .health-fill {
            height: 100%;
            transition: width 0.3s ease, background-color 0.3s;
        }

        /* Powerup Icons Animation */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        .floating {
            animation: float 2s ease-in-out infinite;
        }

        /* Mobile Controls */
        .joystick-zone {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: none; /* Hidden on desktop by default */
        }
        
        .fire-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: rgba(239, 68, 68, 0.6);
            border-radius: 50%;
            display: none;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            user-select: none;
            border: 4px solid rgba(255,255,255,0.2);
        }

        .active-powerup {
            border: 2px solid #fbbf24;
            box-shadow: 0 0 10px #fbbf24;
        }

        @media (max-width: 768px) {
            .joystick-zone, .fire-btn { display: flex; }
            .desktop-hint { display: none; }
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center relative">

    <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© / Ø§Ù„Ù„ÙˆØ¨ÙŠ -->
    <div id="lobbyScreen" class="absolute inset-0 z-50 flex items-center justify-center bg-slate-900 bg-opacity-95 p-4">
        <div class="ui-panel p-8 rounded-2xl max-w-md w-full text-center shadow-2xl">
            <h1 class="text-4xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600">Ù…Ø¹Ø±ÙƒØ© Ø§Ù„Ø£Ø³Ù‡Ù…</h1>
            <p class="text-slate-400 mb-8">Ù„Ø¹Ø¨Ø© 1 Ø¶Ø¯ 1 Ù…Ø¹ ØªØ·ÙˆÙŠØ±Ø§Øª Ù‚ØªØ§Ù„ÙŠØ©</p>
            
            <div id="authSection">
                <p class="mb-4 text-sm animate-pulse">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…...</p>
            </div>

            <div id="roomSection" class="hidden space-y-4">
                <div class="flex flex-col gap-3">
                    <button id="createRoomBtn" class="bg-blue-600 hover:bg-blue-700 text-white py-3 px-6 rounded-lg font-bold transition transform hover:scale-105 shadow-lg shadow-blue-500/30">
                        Ø¥Ù†Ø´Ø§Ø¡ ØºØ±ÙØ© Ø¬Ø¯ÙŠØ¯Ø©
                    </button>
                    <div class="relative">
                        <div class="absolute inset-0 flex items-center">
                            <div class="w-full border-t border-gray-600"></div>
                        </div>
                        <div class="relative flex justify-center text-sm">
                            <span class="px-2 bg-slate-800 text-gray-400">Ø£Ùˆ</span>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <input type="text" id="roomIdInput" placeholder="Ø£Ø¯Ø®Ù„ Ø±Ù…Ø² Ø§Ù„ØºØ±ÙØ©" class="flex-1 bg-slate-700 border border-slate-600 text-white rounded-lg px-4 py-2 focus:outline-none focus:border-cyan-400 dir-ltr text-center">
                        <button id="joinRoomBtn" class="bg-emerald-600 hover:bg-emerald-700 text-white py-2 px-4 rounded-lg font-bold transition">
                            Ø§Ù†Ø¶Ù…Ø§Ù…
                        </button>
                    </div>
                </div>
            </div>

            <div id="waitingMsg" class="hidden mt-6">
                <div class="flex items-center justify-center gap-3">
                    <div class="w-3 h-3 bg-cyan-400 rounded-full animate-bounce"></div>
                    <div class="w-3 h-3 bg-cyan-400 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
                    <div class="w-3 h-3 bg-cyan-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                </div>
                <p class="mt-2 text-cyan-300 font-bold" id="roomCodeDisplay"></p>
                <p class="text-sm text-slate-400">Ø´Ø§Ø±Ùƒ Ø§Ù„Ø±Ù…Ø² Ù…Ø¹ ØµØ¯ÙŠÙ‚Ùƒ</p>
            </div>
        </div>
    </div>

    <!-- ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù„Ø¹Ø¨ -->
    <div id="gameUI" class="absolute inset-0 pointer-events-none hidden flex-col justify-between p-4 z-40">
        <!-- Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ -->
        <div class="flex justify-between items-start w-full">
            <!-- Ù„Ø§Ø¹Ø¨ 1 -->
            <div class="flex flex-col items-start gap-1">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-cyan-500 box-shadow-glow"></div>
                    <span class="font-bold text-cyan-400">Ø£Ù†Øª</span>
                </div>
                <div class="health-bar-container">
                    <div id="myHealth" class="health-fill bg-gradient-to-r from-cyan-500 to-blue-600" style="width: 100%;"></div>
                </div>
                <div id="myPowerups" class="flex gap-2 mt-1 min-h-[30px]">
                    <!-- Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª Ø§Ù„ØªØ·ÙˆÙŠØ±Ø§Øª Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ -->
                </div>
            </div>

            <!-- Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙˆØ§Ù„ÙˆÙ‚Øª (Ø§Ø®ØªÙŠØ§Ø±ÙŠ) -->
            <div class="bg-slate-800/80 px-4 py-2 rounded-lg border border-slate-700">
                <span class="text-xl font-mono font-bold text-white tracking-widest">VS</span>
            </div>

            <!-- Ù„Ø§Ø¹Ø¨ 2 -->
            <div class="flex flex-col items-end gap-1">
                <div class="flex items-center gap-2">
                    <span class="font-bold text-red-400">Ø§Ù„Ø®ØµÙ…</span>
                    <div class="w-3 h-3 rounded-full bg-red-500"></div>
                </div>
                <div class="health-bar-container border-red-900/50">
                    <div id="opponentHealth" class="health-fill bg-gradient-to-r from-red-500 to-orange-600" style="width: 100%;"></div>
                </div>
                <div id="opponentPowerups" class="flex gap-2 mt-1 min-h-[30px] justify-end">
                    <!-- Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª Ø§Ù„Ø®ØµÙ… -->
                </div>
            </div>
        </div>

        <!-- Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… -->
        <div id="gameMessage" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none hidden">
            <h2 id="msgText" class="text-5xl font-bold drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)] text-white"></h2>
        </div>

        <!-- Ø¹Ù†Ø§ØµØ± ØªØ­ÙƒÙ… Ø§Ù„Ø¬ÙˆØ§Ù„ -->
        <div class="w-full h-full relative pointer-events-auto">
            <div id="joystickZone" class="joystick-zone"></div>
            <div id="fireBtn" class="fire-btn active:scale-90 transition">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
            </div>
            <div class="desktop-hint absolute bottom-4 left-1/2 -translate-x-1/2 text-slate-500 text-sm bg-slate-900/80 px-3 py-1 rounded">
                WASD Ù„Ù„ØªØ­Ø±Ùƒ | Ø§Ù„Ù…Ø§ÙˆØ³ Ù„Ù„ØªØµÙˆÙŠØ¨ | Ø§Ù†Ù‚Ø± Ù„Ù„Ø¥Ø·Ù„Ø§Ù‚
            </div>
        </div>
    </div>

    <canvas id="gameCanvas" class="bg-slate-800"></canvas>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, updateDoc, deleteDoc, getDoc, arrayUnion, arrayRemove, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- ØªÙ‡ÙŠØ¦Ø© Firebase ---
        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Firebase Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù…Ø´Ø±ÙˆØ¹Ùƒ
        const firebaseConfig = {
            apiKey: "AIzaSyD6MRZ7d7J1333erYoBrUGqocJNdGNjB7w",
            authDomain: "neew-aec2b.firebaseapp.com",
            databaseURL: "https://neew-aec2b-default-rtdb.firebaseio.com",
            projectId: "neew-aec2b",
            storageBucket: "neew-aec2b.firebasestorage.app",
            messagingSenderId: "70112873200",
            appId: "1:70112873200:web:b8ef2b3863be6f1bf39035"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Ù†Ø³ØªØ®Ø¯Ù… Ù…Ø¹Ø±Ù Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù„ØªÙ†Ø¸ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø§Ø®Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';

        // --- Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© ---
        let currentUser = null;
        let roomId = null;
        let isHost = false;
        let gameActive = false;
        let canvas, ctx;
        let animationFrameId;
        
        // ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
        const GAME_WIDTH = 1200;
        const GAME_HEIGHT = 800;
        const PLAYER_RADIUS = 25;
        const BASE_SPEED = 5;
        
        let localPlayer = {
            id: null,
            x: 100,
            y: 400,
            color: '#06b6d4', // Cyan
            angle: 0,
            health: 100,
            powerups: [],
            speed: BASE_SPEED,
            shield: false
        };

        let remotePlayer = {
            id: null,
            x: 1100,
            y: 400,
            color: '#ef4444', // Red
            angle: Math.PI,
            health: 100,
            powerups: [],
            shield: false
        };

        let arrows = []; // { x, y, vx, vy, ownerId, isDouble }
        let powerups = []; // { id, type, x, y }
        let particles = [];
        let mousePos = { x: 0, y: 0 };
        let keys = {};
        
        // Joystick data
        let joystickData = { active: false, x: 0, y: 0 };

        // Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ØªØ·ÙˆÙŠØ±Ø§Øª
        const POWERUP_TYPES = {
            SPEED: { color: '#fbbf24', label: 'âš¡', name: 'Ø³Ø±Ø¹Ø© Ø®Ø§Ø±Ù‚Ø©', duration: 5000 },
            DOUBLE: { color: '#a855f7', label: 'ğŸ¹', name: 'Ø³Ù‡Ù… Ù…Ø²Ø¯ÙˆØ¬', duration: 8000 },
            SHIELD: { color: '#3b82f6', label: 'ğŸ›¡ï¸', name: 'Ø¯Ø±Ø¹ Ø­Ù…Ø§ÙŠØ©', duration: 6000 }
        };

        // --- Ø§Ù„ØµÙˆØª (Simple Synth) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'shoot') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'hit') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'powerup') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            }
        }

        // --- Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ ---

        async function init() {
            // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
            const authSection = document.getElementById('authSection');
            const roomSection = document.getElementById('roomSection');

            try {
                // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªÙˆÙƒÙ† Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆÙØ±Ø§Ù‹ (Ù„Ù„Ø¨ÙŠØ¦Ø§Øª Ø§Ù„Ø®Ø§ØµØ©)ØŒ ÙˆØ¥Ù„Ø§ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù…Ø¬Ù‡ÙˆÙ„
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await auth.signInWithCustomToken(__initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.warn("ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø§Ù„ØªÙˆÙƒÙ† (Ø±Ø¨Ù…Ø§ Ø¨Ø³Ø¨Ø¨ Ø§Ø®ØªÙ„Ø§Ù Ø§Ù„Ù…Ø´Ø±ÙˆØ¹)ØŒ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ÙƒÙ…Ø¬Ù‡ÙˆÙ„:", error);
                await signInAnonymously(auth);
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    localPlayer.id = user.uid;
                    authSection.classList.add('hidden');
                    roomSection.classList.remove('hidden');
                }
            });

            // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Canvas
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Ø§Ù„Ù…Ø³ØªÙ…Ø¹ÙŠÙ† Ù„Ù„Ø£Ø­Ø¯Ø§Ø«
            setupInputs();
            
            // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù„ÙˆØ¨ÙŠ
            document.getElementById('createRoomBtn').addEventListener('click', createRoom);
            document.getElementById('joinRoomBtn').addEventListener('click', joinRoom);
        }

        function resizeCanvas() {
            // Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø³Ø¨Ø©
            const aspectRatio = GAME_WIDTH / GAME_HEIGHT;
            let w = window.innerWidth;
            let h = window.innerHeight;
            
            if (w / h > aspectRatio) {
                w = h * aspectRatio;
            } else {
                h = w / aspectRatio;
            }
            
            canvas.style.width = `${w}px`;
            canvas.style.height = `${h}px`;
            // Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
        }

        // --- Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØºØ±Ù (Firebase) ---

        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø±Ø¬Ø¹ Ø§Ù„ØºØ±ÙØ© Ø§Ù„ØµØ­ÙŠØ­
        function getRoomRef(rId) {
            // Ø§Ù„Ù…Ø³Ø§Ø±: artifacts/{appId}/public/data/rooms/{roomId}
            return doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${rId}`);
        }

        async function createRoom() {
            roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
            isHost = true;
            localPlayer.x = 100; // Host on left
            localPlayer.color = '#06b6d4';

            const roomRef = getRoomRef(roomId);
            
            await setDoc(roomRef, {
                host: localPlayer.id,
                status: 'waiting',
                created: serverTimestamp(),
                players: {
                    [localPlayer.id]: { x: 100, y: 400, hp: 100, buffs: [] }
                },
                arrows: [], // For syncing shoot events mostly
                powerups: []
            });

            document.getElementById('roomSection').classList.add('hidden');
            document.getElementById('waitingMsg').classList.remove('hidden');
            document.getElementById('roomCodeDisplay').innerText = `Ø±Ù…Ø² Ø§Ù„ØºØ±ÙØ©: ${roomId}`;

            // Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
            listenToRoom(roomRef);
        }

        async function joinRoom() {
            const code = document.getElementById('roomIdInput').value.trim().toUpperCase();
            if (!code) return alert('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø±Ù…Ø²');
            
            roomId = code;
            isHost = false;
            localPlayer.x = GAME_WIDTH - 100; // Joiner on right
            localPlayer.color = '#ef4444'; 

            const roomRef = getRoomRef(roomId);
            const docSnap = await getDoc(roomRef);

            if (docSnap.exists() && docSnap.data().status === 'waiting') {
                // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø«Ø§Ù†ÙŠ
                await updateDoc(roomRef, {
                    [`players.${localPlayer.id}`]: { x: GAME_WIDTH - 100, y: 400, hp: 100, buffs: [] },
                    status: 'playing',
                    joiner: localPlayer.id
                });
                startGame(roomRef);
            } else {
                alert('Ø§Ù„ØºØ±ÙØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© Ø£Ùˆ Ù…Ù…ØªÙ„Ø¦Ø©');
            }
        }

        function listenToRoom(roomRef) {
            const unsub = onSnapshot(roomRef, (doc) => {
                const data = doc.data();
                if (!data) return;

                if (data.status === 'playing' && !gameActive) {
                    startGame(roomRef);
                }
            });
        }

        // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ ---

        let lastSyncTime = 0;
        let gameLoopRef;
        let unsubscribeRoom = null;

        function startGame(roomRef) {
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('gameUI').classList.remove('hidden');
            document.getElementById('gameUI').style.display = 'flex';
            
            gameActive = true;
            
            // Ø§Ù„Ø¨Ø¯Ø¡ ÙÙŠ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©
            unsubscribeRoom = onSnapshot(roomRef, (snapshot) => {
                const data = snapshot.data();
                if (!data) return;

                // Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ø®ØµÙ…
                const otherPlayerId = Object.keys(data.players).find(id => id !== localPlayer.id);
                if (otherPlayerId && data.players[otherPlayerId]) {
                    const pData = data.players[otherPlayerId];
                    // Interpolation (simple lerp target)
                    remotePlayer.id = otherPlayerId;
                    remotePlayer.targetX = pData.x;
                    remotePlayer.targetY = pData.y;
                    remotePlayer.angle = pData.angle;
                    remotePlayer.health = pData.hp;
                    remotePlayer.shield = (pData.buffs || []).includes('SHIELD');
                    
                    // Update buffs UI for opponent
                    updateBuffsUI(pData.buffs || [], 'opponentPowerups');
                    
                    // Check for damage (if I took damage locally, I updated my HP, but if remote host says I took damage?)
                    // For simplicity: Damage is calculated by the shooter and pushed to the victim's HP on DB.
                    if (data.players[localPlayer.id] && data.players[localPlayer.id].hp < localPlayer.health) {
                         localPlayer.health = data.players[localPlayer.id].hp;
                         createExplosion(localPlayer.x, localPlayer.y, '#ff0000');
                         playSound('hit');
                    }
                }

                // Sync Arrows (Only new ones)
                // We rely on "events" array in Firestore ideally, but here we just check array changes
                // Better approach: When data.lastShoot changes, spawn arrow
                if (data.lastShoot && data.lastShoot.byId !== localPlayer.id && data.lastShoot.ts !== remotePlayer.lastShootTs) {
                    remotePlayer.lastShootTs = data.lastShoot.ts;
                    spawnArrow(
                        data.lastShoot.x, 
                        data.lastShoot.y, 
                        data.lastShoot.angle, 
                        remotePlayer.id, 
                        data.lastShoot.isDouble
                    );
                }

                // Sync Powerups
                powerups = data.powerups || [];
                
                // Game Over Check
                if (localPlayer.health <= 0 || remotePlayer.health <= 0) {
                    endGame(localPlayer.health > 0);
                }
            });

            // Start Loop
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
            
            // Host logic for spawning powerups
            if (isHost) {
                startPowerupSpawner(roomRef);
            }
        }

        function startPowerupSpawner(roomRef) {
            setInterval(async () => {
                if (!gameActive) return;
                // Only spawn if less than 3 active
                if (powerups.length < 3) {
                    const types = Object.keys(POWERUP_TYPES);
                    const type = types[Math.floor(Math.random() * types.length)];
                    const newPowerup = {
                        id: Date.now().toString(),
                        type: type,
                        x: 100 + Math.random() * (GAME_WIDTH - 200),
                        y: 100 + Math.random() * (GAME_HEIGHT - 200)
                    };
                    
                    // Atomic Add
                    await updateDoc(roomRef, {
                        powerups: arrayUnion(newPowerup)
                    });
                }
            }, 10000); // Every 10 seconds
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameActive) return;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(dt);
            draw();
            
            // Sync Rate Limiter (10 times per second)
            if (timestamp - lastSyncTime > 100) {
                syncState();
                lastSyncTime = timestamp;
            }

            requestAnimationFrame(gameLoop);
        }

        // --- Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙˆØ§Ù„Ø±Ø³Ù… ---

        function update(dt) {
            // 1. Movement
            let dx = 0;
            let dy = 0;

            // Keyboard
            if (keys['ArrowUp'] || keys['w']) dy = -1;
            if (keys['ArrowDown'] || keys['s']) dy = 1;
            if (keys['ArrowLeft'] || keys['a']) dx = -1;
            if (keys['ArrowRight'] || keys['d']) dx = 1;
            
            // Joystick
            if (joystickData.active) {
                dx = joystickData.x;
                dy = joystickData.y;
            }

            // Normalize and Move
            if (dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx*dx + dy*dy);
                // Apply speed buff
                const currentSpeed = localPlayer.powerups.includes('SPEED') ? BASE_SPEED * 1.5 : BASE_SPEED;
                
                localPlayer.x += (dx / (len || 1)) * currentSpeed;
                localPlayer.y += (dy / (len || 1)) * currentSpeed;

                // Boundaries
                localPlayer.x = Math.max(PLAYER_RADIUS, Math.min(GAME_WIDTH - PLAYER_RADIUS, localPlayer.x));
                localPlayer.y = Math.max(PLAYER_RADIUS, Math.min(GAME_HEIGHT - PLAYER_RADIUS, localPlayer.y));
            }

            // Angle (Look at mouse or joystick direction)
            if (joystickData.active) {
                localPlayer.angle = Math.atan2(joystickData.y, joystickData.x);
            } else {
                // Calculate mouse angle relative to canvas scaling
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mx = (mousePos.x - rect.left) * scaleX;
                const my = (mousePos.y - rect.top) * scaleY;
                localPlayer.angle = Math.atan2(my - localPlayer.y, mx - localPlayer.x);
            }

            // Remote Player Interpolation
            if (remotePlayer.targetX !== undefined) {
                remotePlayer.x += (remotePlayer.targetX - remotePlayer.x) * 0.1;
                remotePlayer.y += (remotePlayer.targetY - remotePlayer.y) * 0.1;
            }

            // 2. Update Arrows
            for (let i = arrows.length - 1; i >= 0; i--) {
                const a = arrows[i];
                a.x += a.vx;
                a.y += a.vy;

                // Wall collision
                if (a.x < 0 || a.x > GAME_WIDTH || a.y < 0 || a.y > GAME_HEIGHT) {
                    arrows.splice(i, 1);
                    continue;
                }

                // Player Hit Check (Only check if *I* hit the *Remote*)
                // This simplifies logic: shooter claims the hit.
                if (a.ownerId === localPlayer.id) {
                    const dist = Math.hypot(a.x - remotePlayer.x, a.y - remotePlayer.y);
                    if (dist < PLAYER_RADIUS + 10) {
                        // HIT!
                        if (!remotePlayer.shield) {
                            applyDamageToRemote(10);
                        } else {
                            createExplosion(a.x, a.y, '#3b82f6'); // Shield hit
                        }
                        createExplosion(a.x, a.y, '#ef4444');
                        playSound('hit');
                        arrows.splice(i, 1);
                        continue;
                    }
                } 
                // Check if *Remote* hit *Me* (Visual only, damage handled by shooter logic above or strictly locally to prevent lag cheating. 
                // Let's stick to: Shooter updates DB. So here we just show visual effect if I get hit)
                else if (a.ownerId !== localPlayer.id) {
                     const dist = Math.hypot(a.x - localPlayer.x, a.y - localPlayer.y);
                     if (dist < PLAYER_RADIUS + 10) {
                         createExplosion(a.x, a.y, localPlayer.color);
                         arrows.splice(i, 1); // Remove arrow visually
                     }
                }
            }

            // 3. Powerups Collision
            for (let i = 0; i < powerups.length; i++) {
                const p = powerups[i];
                const dist = Math.hypot(p.x - localPlayer.x, p.y - localPlayer.y);
                if (dist < PLAYER_RADIUS + 20) {
                    claimPowerup(p);
                }
            }

            // 4. Particles
            updateParticles();
        }

        function draw() {
            // Background grid
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let x=0; x<=GAME_WIDTH; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,GAME_HEIGHT); }
            for(let y=0; y<=GAME_HEIGHT; y+=50) { ctx.moveTo(0,y); ctx.lineTo(GAME_WIDTH,y); }
            ctx.stroke();

            // Draw Powerups
            powerups.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                const info = POWERUP_TYPES[p.type];
                
                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = info.color;
                
                // Circle
                ctx.fillStyle = info.color;
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Text
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(info.label, 0, 2);
                
                ctx.restore();
            });

            // Draw Arrows
            arrows.forEach(a => {
                ctx.save();
                ctx.translate(a.x, a.y);
                ctx.rotate(Math.atan2(a.vy, a.vx));
                
                ctx.fillStyle = a.ownerId === localPlayer.id ? '#67e8f9' : '#fca5a5';
                ctx.shadowBlur = 10;
                ctx.shadowColor = ctx.fillStyle;
                
                if(a.isDouble) {
                    ctx.fillRect(-10, -5, 20, 4);
                    ctx.fillRect(-10, 1, 20, 4);
                } else {
                    ctx.fillRect(-15, -2, 30, 4);
                    ctx.beginPath();
                    ctx.moveTo(15, -5);
                    ctx.lineTo(25, 0);
                    ctx.lineTo(15, 5);
                    ctx.fill();
                }
                ctx.restore();
            });

            // Draw Players
            drawPlayer(localPlayer);
            drawPlayer(remotePlayer);

            // Particles
            drawParticles();
        }

        function drawPlayer(p) {
            ctx.save();
            ctx.translate(p.x, p.y);
            
            // Shield Effect
            if (p.shield) {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#3b82f6';
                ctx.beginPath();
                ctx.arc(0, 0, PLAYER_RADIUS + 8, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.rotate(p.angle);
            
            // Body
            ctx.fillStyle = p.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = p.color;
            ctx.beginPath();
            ctx.arc(0, 0, PLAYER_RADIUS, 0, Math.PI * 2);
            ctx.fill();

            // Gun/Direction
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, -5, 35, 10);
            
            ctx.restore();
        }

        function spawnArrow(x, y, angle, ownerId, isDouble) {
            const speed = 15;
            const createArrow = (offsetAngle) => {
                arrows.push({
                    x: x + Math.cos(angle) * 30,
                    y: y + Math.sin(angle) * 30,
                    vx: Math.cos(angle + offsetAngle) * speed,
                    vy: Math.sin(angle + offsetAngle) * speed,
                    ownerId: ownerId,
                    isDouble: isDouble
                });
            };

            playSound('shoot');
            createArrow(0);
            if (isDouble) {
                createArrow(0.1);
                createArrow(-0.1);
            }
        }

        // --- Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª (Shoot, Buffs) ---

        function shoot() {
            if (!gameActive) return;
            const isDouble = localPlayer.powerups.includes('DOUBLE');
            
            // Local visual immediate
            spawnArrow(localPlayer.x, localPlayer.y, localPlayer.angle, localPlayer.id, isDouble);

            // Sync Event
            const roomRef = getRoomRef(roomId);
            updateDoc(roomRef, {
                lastShoot: {
                    byId: localPlayer.id,
                    x: localPlayer.x,
                    y: localPlayer.y,
                    angle: localPlayer.angle,
                    isDouble: isDouble,
                    ts: Date.now()
                }
            });
        }

        async function claimPowerup(p) {
            // Remove locally immediately to prevent double trigger
            const idx = powerups.indexOf(p);
            if (idx > -1) powerups.splice(idx, 1);

            playSound('powerup');
            
            // Activate Buff
            activateBuff(p.type);

            // Sync Removal
            const roomRef = getRoomRef(roomId);
            await updateDoc(roomRef, {
                powerups: arrayRemove(p)
            });
        }

        function activateBuff(type) {
            if (localPlayer.powerups.includes(type)) return; // Already have it

            localPlayer.powerups.push(type);
            updateBuffsUI(localPlayer.powerups, 'myPowerups');

            // Apply Effect logic
            if (type === 'SHIELD') localPlayer.shield = true;

            // Sync buff state to DB so opponent sees it
            syncState();

            // Timer to remove buff
            setTimeout(() => {
                localPlayer.powerups = localPlayer.powerups.filter(b => b !== type);
                if(type === 'SHIELD') localPlayer.shield = false;
                updateBuffsUI(localPlayer.powerups, 'myPowerups');
                syncState();
            }, POWERUP_TYPES[type].duration);
        }

        async function applyDamageToRemote(dmg) {
            // Update remote player HP in DB
            const roomRef = getRoomRef(roomId);
            // Note: In a secure app, we'd use transactions. Here simpler is better for speed.
            // We read latest remote HP from our local cache of it
            const newHp = remotePlayer.health - dmg;
            
            await updateDoc(roomRef, {
                [`players.${remotePlayer.id}.hp`]: newHp
            });
        }

        async function syncState() {
            if (!roomId || !localPlayer.id) return;
            
            const roomRef = getRoomRef(roomId);
            
            // Only sync essential data
            await updateDoc(roomRef, {
                [`players.${localPlayer.id}`]: {
                    x: Math.round(localPlayer.x),
                    y: Math.round(localPlayer.y),
                    angle: parseFloat(localPlayer.angle.toFixed(2)),
                    hp: localPlayer.health,
                    buffs: localPlayer.powerups
                }
            });
            
            // Update UI Health locally
            document.getElementById('myHealth').style.width = `${localPlayer.health}%`;
            document.getElementById('opponentHealth').style.width = `${remotePlayer.health}%`;
        }

        // --- Helper: UI & Input ---

        function updateBuffsUI(buffs, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            buffs.forEach(b => {
                const div = document.createElement('div');
                div.className = 'w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold shadow-lg ' + (containerId === 'myPowerups' ? 'active-powerup' : '');
                div.style.backgroundColor = POWERUP_TYPES[b].color;
                div.innerText = POWERUP_TYPES[b].label;
                container.appendChild(div);
            });
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<10; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color
                });
            }
        }

        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }

        function endGame(won) {
            gameActive = false;
            const msgEl = document.getElementById('gameMessage');
            const txtEl = document.getElementById('msgText');
            msgEl.classList.remove('hidden');
            
            if (won) {
                txtEl.innerText = "ğŸ† ÙØ²Øª!";
                txtEl.classList.add('text-green-400');
            } else {
                txtEl.innerText = "ğŸ’€ Ø®Ø³Ø±Øª!";
                txtEl.classList.add('text-red-500');
            }
            
            setTimeout(() => {
                // Reset logic could go here
               // location.reload(); // Simple restart
            }, 3000);
        }

        // --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­ÙƒÙ… ---
        function setupInputs() {
            // Keyboard
            window.addEventListener('keydown', e => keys[e.key] = true);
            window.addEventListener('keyup', e => keys[e.key] = false);
            
            // Mouse
            window.addEventListener('mousemove', e => {
                mousePos.x = e.clientX;
                mousePos.y = e.clientY;
            });
            window.addEventListener('mousedown', shoot);

            // Touch / Joystick (Basic Implementation)
            const joystickZone = document.getElementById('joystickZone');
            let touchId = null;
            let startX, startY;

            joystickZone.addEventListener('touchstart', e => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                touchId = touch.identifier;
                startX = touch.clientX;
                startY = touch.clientY;
                joystickData.active = true;
            });

            joystickZone.addEventListener('touchmove', e => {
                e.preventDefault();
                for (let i=0; i<e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        const touch = e.changedTouches[i];
                        const dx = touch.clientX - startX;
                        const dy = touch.clientY - startY;
                        
                        // Limit radius
                        const dist = Math.min(50, Math.hypot(dx, dy));
                        const angle = Math.atan2(dy, dx);
                        
                        joystickData.x = Math.cos(angle) * (dist/50);
                        joystickData.y = Math.sin(angle) * (dist/50);
                    }
                }
            });

            joystickZone.addEventListener('touchend', e => {
                joystickData.active = false;
                joystickData.x = 0;
                joystickData.y = 0;
            });

            document.getElementById('fireBtn').addEventListener('touchstart', (e) => {
                e.preventDefault(); // prevent zoom
                shoot();
            });
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
        init();

    </script>
</body>
</html>
