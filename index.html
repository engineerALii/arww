<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ø±Ù…Ø§Ø© Ø§Ù„Ø³Ù‡Ø§Ù… - Ragdoll Archers Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Cairo', sans-serif; overflow: hidden; touch-action: none; background-color: #1a202c; user-select: none; -webkit-tap-highlight-color: transparent; }
        canvas { display: block; width: 100%; height: 100%; outline: none; }
        .game-ui { position: absolute; pointer-events: none; width: 100%; height: 100%; top: 0; left: 0; z-index: 10; }
        .interactive { pointer-events: auto; }
        .health-bar { transition: width 0.2s ease-out; }
        
        /* Ø²Ø± Ø§Ù„Ù„Ù…Ø³ */
        .touch-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(4px);
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        .touch-btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* ØªØ­Ø°ÙŠØ± Ø§Ù„ØªØ¯ÙˆÙŠØ± Ù„Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ */
        #rotate-warning { display: none; }
        @media (max-width: 768px) and (orientation: portrait) {
            #rotate-warning { display: flex; }
            #game-container { display: none; }
        }
    </style>
</head>
<body>

    <!-- Ø´Ø§Ø´Ø© ØªØ­Ø°ÙŠØ± Ø§Ù„ØªØ¯ÙˆÙŠØ± -->
    <div id="rotate-warning" class="fixed inset-0 z-[100] bg-gray-900 text-white flex-col items-center justify-center p-8 text-center">
        <div class="text-6xl mb-4">ğŸ”„</div>
        <h2 class="text-2xl font-bold mb-2">ÙŠØ±Ø¬Ù‰ ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø¬Ù‡Ø§Ø²</h2>
        <p class="text-gray-400">Ù‡Ø°Ù‡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…ØµÙ…Ù…Ø© Ù„Ù„Ø¹Ø¨ Ø¨Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø£ÙÙ‚ÙŠ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ ØªØ¬Ø±Ø¨Ø©.</p>
    </div>

    <div id="game-container" class="relative w-full h-screen">
        <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© / Ø§Ù„Ù†Ù‡Ø§ÙŠØ© -->
        <div id="overlay-screen" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-gray-900 bg-opacity-95 text-white interactive transition-opacity duration-300 px-4">
            <h1 class="text-4xl md:text-6xl font-bold mb-4 text-yellow-400 drop-shadow-lg text-center">Ø±Ù…Ø§Ø© Ø§Ù„Ø³Ù‡Ø§Ù…</h1>
            <p id="overlay-msg" class="mb-8 text-lg md:text-xl text-gray-300 text-center max-w-md">
                <span class="hidden md:inline">Ø§Ù„ØªØ­ÙƒÙ…: Ø§Ù„Ø£Ø³Ù‡Ù… Ù„Ù„Ø­Ø±ÙƒØ©ØŒ Ø§Ù„Ù…Ø§ÙˆØ³ Ù„Ù„ØªØµÙˆÙŠØ¨</span>
                <span class="md:hidden">Ø§Ù„ØªØ­ÙƒÙ…: Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø´Ø§Ø´Ø© Ù„Ù„Ø­Ø±ÙƒØ©ØŒ Ø§Ù„Ù„Ù…Ø³ ÙˆØ§Ù„Ø³Ø­Ø¨ Ù„Ù„ØªØµÙˆÙŠØ¨</span>
            </p>
            
            <div class="flex flex-col gap-4 w-full max-w-xs">
                <button id="btn-create" class="px-6 py-4 bg-green-600 hover:bg-green-700 rounded-xl text-lg md:text-xl font-bold shadow-lg transition transform active:scale-95 w-full flex items-center justify-center gap-2">
                    <span>âš”ï¸</span> Ø¨Ø­Ø« Ø¹Ù† Ø®ØµÙ…
                </button>
                <button id="btn-restart" class="hidden px-6 py-4 bg-blue-600 hover:bg-blue-700 rounded-xl text-lg md:text-xl font-bold shadow-lg transition transform active:scale-95 w-full">
                    ğŸ”„ Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
                </button>
            </div>
            
            <p id="status-text" class="mt-6 text-sm md:text-base text-yellow-500 font-mono min-h-[20px] text-center px-4"></p>
        </div>

        <!-- ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù„Ø¹Ø¨ -->
        <div id="hud" class="game-ui hidden">
            <!-- P1 (You) -->
            <div class="absolute top-4 right-4 flex flex-col items-end w-32 md:w-64">
                <div class="flex items-center gap-2 mb-1">
                    <span class="text-white font-bold drop-shadow-md text-sm md:text-base">Ø£Ù†Øª</span>
                    <div class="w-6 h-6 md:w-8 md:h-8 rounded-full bg-blue-500 border-2 border-white flex items-center justify-center text-xs">ğŸ‘¤</div>
                </div>
                <div class="w-full bg-gray-800 h-3 md:h-4 rounded-full border border-gray-600 overflow-hidden relative">
                    <div id="p1-health" class="h-full bg-green-500 w-full health-bar absolute right-0"></div>
                </div>
            </div>

            <!-- P2 (Enemy) -->
            <div class="absolute top-4 left-4 flex flex-col items-start w-32 md:w-64">
                <div class="flex items-center gap-2 mb-1">
                    <div class="w-6 h-6 md:w-8 md:h-8 rounded-full bg-red-500 border-2 border-white flex items-center justify-center text-xs">ğŸ’€</div>
                    <span class="text-white font-bold drop-shadow-md text-sm md:text-base">Ø§Ù„Ø®ØµÙ…</span>
                </div>
                <div class="w-full bg-gray-800 h-3 md:h-4 rounded-full border border-gray-600 overflow-hidden relative">
                    <div id="p2-health" class="h-full bg-red-500 w-full health-bar absolute left-0"></div>
                </div>
            </div>

            <!-- Mobile Controls -->
            <div class="absolute bottom-6 w-full px-4 md:px-8 flex justify-between interactive md:hidden pointer-events-none pb-safe">
                <div class="flex gap-4 pointer-events-auto">
                    <button id="btn-left" class="touch-btn w-16 h-16 rounded-full text-3xl shadow-xl">â¬…ï¸</button>
                    <button id="btn-right" class="touch-btn w-16 h-16 rounded-full text-3xl shadow-xl">â¡ï¸</button>
                </div>
                <div class="pointer-events-auto">
                    <button id="btn-jump" class="touch-btn w-16 h-16 rounded-full text-3xl shadow-xl">â¬†ï¸</button>
                </div>
            </div>
        </div>
        
        <div id="canvas-wrapper" class="w-full h-full cursor-crosshair"></div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, updateDoc, deleteDoc, getDocs, query, where, limit, arrayUnion } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        // --- Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyD6MRZ7d7J1333erYoBrUGqocJNdGNjB7w",
            authDomain: "neew-aec2b.firebaseapp.com",
            databaseURL: "https://neew-aec2b-default-rtdb.firebaseio.com",
            projectId: "neew-aec2b",
            storageBucket: "neew-aec2b.firebasestorage.app",
            messagingSenderId: "70112873200",
            appId: "1:70112873200:web:b8ef2b3863be6f1bf39035"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const APP_ID = typeof __app_id !== 'undefined' ? __app_id : 'ragdoll-v2';
        const MATCHES_COLL = `artifacts/${APP_ID}/public/data/matches_v2`;

        // --- Physics Engine Constants ---
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Body = Matter.Body,
              Composite = Matter.Composite,
              Constraint = Matter.Constraint,
              Events = Matter.Events,
              Vector = Matter.Vector;

        const CAT_PLAYER = 0x0001, CAT_ARROW = 0x0002, CAT_GROUND = 0x0004, CAT_SENSOR = 0x0008;

        // --- Game State ---
        let engine, render, runner;
        let myUserId = null;
        let matchId = null;
        let isHost = false;
        let playerMe = null;
        let playerOpponent = null;
        let keys = { ArrowUp: false, ArrowLeft: false, ArrowRight: false, w: false, a: false, d: false, " ": false };
        let gameActive = false;
        let lastSync = 0;
        let unsubscribeMatch = null;

        // --- Initialization ---
        async function init() {
            const statusText = document.getElementById('status-text');
            statusText.innerText = "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±...";
            
            try {
                await signInAnonymously(auth);
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        myUserId = user.uid;
                        statusText.innerText = "Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¹Ø¨";
                        document.getElementById('btn-create').onclick = findMatch;
                        document.getElementById('btn-restart').onclick = () => location.reload();
                    }
                });
            } catch (err) {
                statusText.innerText = "ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„: " + err.message;
            }

            // Keyboard Listeners
            window.addEventListener('keydown', (e) => keys[e.key] = true);
            window.addEventListener('keyup', (e) => keys[e.key] = false);

            // Mobile Listeners - Improved to prevent ghost clicks and scrolling
            const bindBtn = (id, key) => {
                const btn = document.getElementById(id);
                const handleStart = (e) => { 
                    e.preventDefault(); 
                    e.stopPropagation();
                    keys[key] = true; 
                    btn.classList.add('scale-90', 'bg-white/30');
                };
                const handleEnd = (e) => { 
                    e.preventDefault(); 
                    e.stopPropagation();
                    keys[key] = false; 
                    btn.classList.remove('scale-90', 'bg-white/30');
                };

                btn.addEventListener('touchstart', handleStart, { passive: false });
                btn.addEventListener('touchend', handleEnd, { passive: false });
                btn.addEventListener('mousedown', handleStart);
                btn.addEventListener('mouseup', handleEnd);
                btn.addEventListener('mouseleave', handleEnd); // Handle drag out
            };

            bindBtn('btn-left', 'ArrowLeft');
            bindBtn('btn-right', 'ArrowRight');
            bindBtn('btn-jump', 'ArrowUp');
        }

        // --- Matchmaking ---
        async function findMatch() {
            const statusText = document.getElementById('status-text');
            const btnCreate = document.getElementById('btn-create');
            btnCreate.disabled = true;
            btnCreate.innerHTML = `<div class="animate-spin h-5 w-5 border-2 border-white border-t-transparent rounded-full mr-2"></div> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...`;
            
            if(unsubscribeMatch) unsubscribeMatch();

            const q = query(collection(db, MATCHES_COLL), where("status", "==", "waiting"), limit(1));
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                const docSnap = querySnapshot.docs[0];
                matchId = docSnap.id;
                isHost = false;
                
                await updateDoc(doc(db, MATCHES_COLL, matchId), {
                    status: "playing",
                    player2: { id: myUserId, hp: 100, x: 800, y: 400 },
                    updatedAt: Date.now()
                });
                
                statusText.innerText = "ØªÙ… Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…! Ø§Ø³ØªØ¹Ø¯...";
                startGame();
            } else {
                isHost = true;
                const newMatchRef = doc(collection(db, MATCHES_COLL));
                matchId = newMatchRef.id;
                
                await setDoc(newMatchRef, {
                    status: "waiting",
                    hostId: myUserId,
                    player1: { id: myUserId, hp: 100, x: 200, y: 400 },
                    player2: null,
                    events: []
                });

                statusText.innerText = "Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ù„Ø§Ø¹Ø¨ Ø¢Ø®Ø±...";
                
                unsubscribeMatch = onSnapshot(doc(db, MATCHES_COLL, matchId), (snap) => {
                    const data = snap.data();
                    if (data && data.status === "playing") {
                        statusText.innerText = "ØªÙ… Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø®ØµÙ…!";
                        startGame();
                    }
                });
            }
        }

        // --- Game Engine ---
        function startGame() {
            document.getElementById('overlay-screen').classList.add('opacity-0', 'pointer-events-none');
            document.getElementById('hud').classList.remove('hidden');
            gameActive = true;

            if (engine) {
                Matter.World.clear(engine.world);
                Matter.Engine.clear(engine);
            }
            if (render) {
                Events.off(render);
                render.canvas.remove();
                render.canvas = null;
            }

            engine = Engine.create();
            engine.gravity.y = 1.5;
            const world = engine.world;

            render = Render.create({
                element: document.getElementById('canvas-wrapper'),
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    wireframes: false,
                    background: '#1a202c',
                    pixelRatio: Math.min(window.devicePixelRatio, 2) // Optimization
                }
            });

            // Make Physics Boundaries Dynamic based on screen
            const w = window.innerWidth;
            const h = window.innerHeight;
            const groundOpts = { isStatic: true, render: { fillStyle: '#2d3748' }, friction: 1, collisionFilter: { category: CAT_GROUND } };
            
            // Build Arena
            Composite.add(world, [
                Bodies.rectangle(w/2, h + 50, w, 160, groundOpts), // Floor
                Bodies.rectangle(w/2, -100, w, 50, groundOpts),    // Ceiling
                Bodies.rectangle(-50, h/2, 100, h * 2, groundOpts), // Left Wall
                Bodies.rectangle(w + 50, h/2, 100, h * 2, groundOpts), // Right Wall
                
                // Platforms - adaptive width
                Bodies.rectangle(w/2, h - 250, Math.min(300, w * 0.4), 20, groundOpts),
                Bodies.rectangle(w * 0.15, h - 450, Math.min(200, w * 0.25), 20, groundOpts),
                Bodies.rectangle(w * 0.85, h - 450, Math.min(200, w * 0.25), 20, groundOpts)
            ]);

            const p1Start = { x: w * 0.15, y: h - 200, color: '#3b82f6' };
            const p2Start = { x: w * 0.85, y: h - 200, color: '#ef4444' };

            if (isHost) {
                playerMe = createPlayer(p1Start.x, p1Start.y, p1Start.color, true);
                playerOpponent = createPlayer(p2Start.x, p2Start.y, p2Start.color, false);
            } else {
                playerMe = createPlayer(p2Start.x, p2Start.y, p2Start.color, true);
                playerOpponent = createPlayer(p1Start.x, p1Start.y, p1Start.color, false);
            }

            Composite.add(world, [playerMe.composite, playerOpponent.composite]);

            Events.on(engine, 'beforeUpdate', gameLoop);
            Events.on(engine, 'collisionStart', handleCollisions);
            
            Events.on(engine, 'afterUpdate', () => {
                if (playerMe && playerMe.body.position.y > window.innerHeight + 100) {
                    takeDamage(100);
                }
            });

            Events.on(render, 'afterRender', () => {
                const ctx = render.context;
                drawAiming(ctx, playerMe);
                drawNames(ctx);
            });

            if (!isHost && unsubscribeMatch) unsubscribeMatch();
            unsubscribeMatch = onSnapshot(doc(db, MATCHES_COLL, matchId), handleNetworkUpdate);

            // Input Listeners
            const canvas = render.canvas;
            canvas.addEventListener('mousedown', startAim);
            canvas.addEventListener('touchstart', (e) => startAim(e.touches[0]), {passive: false});
            window.addEventListener('mousemove', updateAim);
            window.addEventListener('touchmove', (e) => updateAim(e.touches[0]), {passive: false});
            window.addEventListener('mouseup', shoot);
            window.addEventListener('touchend', shoot);
            
            // Handle Resize by just updating render size (physics boundaries remain fixed to initial load for stability in this version)
            window.addEventListener('resize', () => {
                render.canvas.width = window.innerWidth;
                render.canvas.height = window.innerHeight;
            });

            Runner.run(Runner.create(), engine);
            Render.run(render);
        }

        function createPlayer(x, y, color, isMe) {
            const group = Body.nextGroup(true);
            
            const body = Bodies.rectangle(x, y, 30, 50, { 
                collisionFilter: { group: group, category: CAT_PLAYER },
                friction: 0.1, 
                inertia: Infinity, 
                render: { fillStyle: color }
            });
            
            const head = Bodies.circle(x, y - 35, 12, { 
                collisionFilter: { group: group, category: CAT_PLAYER },
                render: { fillStyle: '#fcd34d' }
            });

            const sensor = Bodies.rectangle(x, y + 25, 20, 5, {
                isSensor: true,
                render: { visible: false },
                collisionFilter: { category: CAT_SENSOR }
            });

            const neck = Constraint.create({
                bodyA: body, pointA: { x: 0, y: -25 },
                bodyB: head, pointB: { x: 0, y: 0 },
                stiffness: 1, length: 0, render: { visible: false }
            });

            const sensorConnect = Constraint.create({
                bodyA: body, pointA: { x: 0, y: 25 },
                bodyB: sensor, pointB: { x: 0, y: 0 },
                stiffness: 1, length: 0, render: { visible: false }
            });

            const composite = Composite.create();
            Composite.add(composite, [body, head, sensor, neck, sensorConnect]);

            return {
                composite, body, head, sensor,
                isMe, color,
                hp: 100,
                canJump: false,
                isCharging: false,
                aimAngle: 0,
                aimPower: 0,
                targetPos: { x, y }
            };
        }

        function gameLoop() {
            if (!playerMe || playerMe.hp <= 0) return;

            const speed = 4;
            let velX = 0;
            
            if (keys.ArrowRight || keys.d) velX = speed;
            else if (keys.ArrowLeft || keys.a) velX = -speed;
            
            Body.setVelocity(playerMe.body, { x: velX, y: playerMe.body.velocity.y });

            if ((keys.ArrowUp || keys.w || keys[' ']) && playerMe.canJump) {
                Body.setVelocity(playerMe.body, { x: playerMe.body.velocity.x, y: -14 });
                playerMe.canJump = false;
            }

            const now = Date.now();
            if (now - lastSync > 80) {
                syncState();
                lastSync = now;
            }

            if (playerOpponent) {
                const curr = playerOpponent.body.position;
                const target = playerOpponent.targetPos;
                const dx = target.x - curr.x;
                const dy = target.y - curr.y;
                
                if (Math.abs(dx) > 200 || Math.abs(dy) > 200) {
                    Body.setPosition(playerOpponent.body, target);
                } else {
                    Body.setPosition(playerOpponent.body, {
                        x: curr.x + dx * 0.2,
                        y: curr.y + dy * 0.2
                    });
                    Body.setPosition(playerOpponent.head, {
                        x: playerOpponent.body.position.x,
                        y: playerOpponent.body.position.y - 35
                    });
                }
            }
        }

        function handleCollisions(event) {
            event.pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;

                if (isSensor(bodyA, playerMe) && isGround(bodyB)) playerMe.canJump = true;
                if (isSensor(bodyB, playerMe) && isGround(bodyA)) playerMe.canJump = true;

                let arrow = isArrow(bodyA) ? bodyA : isArrow(bodyB) ? bodyB : null;
                let player = isPlayerPart(bodyA) ? bodyA : isPlayerPart(bodyB) ? bodyB : null;

                if (arrow && player) {
                    const isMyArrow = arrow.label === 'myArrow';
                    const isMyBody = (player === playerMe.body || player === playerMe.head);
                    
                    if (isMyBody && !isMyArrow && !arrow.hasHit) {
                        arrow.hasHit = true;
                        const dmg = (player === playerMe.head) ? 40 : 15;
                        takeDamage(dmg);
                        Composite.remove(engine.world, arrow);
                        
                        document.body.classList.remove('shake');
                        void document.body.offsetWidth;
                        document.body.classList.add('shake');
                    }
                }
            });
        }

        function isSensor(b, p) { return b === p.sensor; }
        function isGround(b) { return b.collisionFilter.category === CAT_GROUND; }
        function isArrow(b) { return b.collisionFilter.category === CAT_ARROW; }
        function isPlayerPart(b) { return b.collisionFilter.category === CAT_PLAYER; }

        let aimStart = null;

        function startAim(pos) {
            if (!playerMe || playerMe.hp <= 0) return;
            const rect = render.canvas.getBoundingClientRect();
            const cx = pos.clientX || pos.x; 
            const cy = pos.clientY || pos.y;
            aimStart = { x: cx - rect.left, y: cy - rect.top };
            playerMe.isCharging = true;
        }

        function updateAim(pos) {
            if (!playerMe.isCharging) return;
            const rect = render.canvas.getBoundingClientRect();
            const cx = pos.clientX || pos.x; 
            const cy = pos.clientY || pos.y;
            const curr = { x: cx - rect.left, y: cy - rect.top };
            
            const dx = aimStart.x - curr.x;
            const dy = aimStart.y - curr.y;
            
            playerMe.aimAngle = Math.atan2(dy, dx);
            playerMe.aimPower = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.05, 25);
        }

        function shoot() {
            if (!playerMe.isCharging) return;
            playerMe.isCharging = false;
            if (playerMe.aimPower < 2) return;

            createArrow(playerMe.body.position.x, playerMe.body.position.y - 20, playerMe.aimAngle, playerMe.aimPower, true);
            
            pushEvent({
                type: 'shoot',
                x: playerMe.body.position.x,
                y: playerMe.body.position.y - 20,
                angle: playerMe.aimAngle,
                power: playerMe.aimPower,
                shooter: myUserId
            });
        }

        function createArrow(x, y, angle, power, isMine) {
            const arrow = Bodies.rectangle(x, y, 40, 4, {
                angle: angle,
                frictionAir: 0.01,
                restitution: 0.5,
                collisionFilter: { category: CAT_ARROW, mask: CAT_GROUND | CAT_PLAYER },
                render: { fillStyle: isMine ? '#fff' : '#fbbf24' },
                label: isMine ? 'myArrow' : 'enemyArrow',
                isSensor: true
            });
            
            const velX = Math.cos(angle) * power;
            const velY = Math.sin(angle) * power;
            Body.setVelocity(arrow, { x: velX, y: velY });

            Composite.add(engine.world, arrow);
            
            setTimeout(() => Composite.remove(engine.world, arrow), 5000);
        }

        function drawAiming(ctx, p) {
            if (p.isCharging) {
                const start = p.body.position;
                const endX = start.x + Math.cos(p.aimAngle) * (p.aimPower * 5);
                const endY = start.y + Math.sin(p.aimAngle) * (p.aimPower * 5);
                
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(endX, endY);
                ctx.lineWidth = 2 + (p.aimPower / 5);
                ctx.strokeStyle = `rgba(255, 255, 255, 0.6)`;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function drawNames(ctx) {
            ctx.font = "bold 14px Cairo";
            ctx.textAlign = "center";
            
            if (playerMe && playerMe.hp > 0) {
                ctx.fillStyle = "#3b82f6";
                ctx.fillText("Ø£Ù†Øª", playerMe.body.position.x, playerMe.body.position.y - 50);
            }
            if (playerOpponent && playerOpponent.hp > 0) {
                ctx.fillStyle = "#ef4444";
                ctx.fillText("Ø§Ù„Ø®ØµÙ…", playerOpponent.body.position.x, playerOpponent.body.position.y - 50);
            }
        }

        async function syncState() {
            if (!matchId || !playerMe) return;
            const myData = isHost ? { player1: getPayload() } : { player2: getPayload() };
            try {
                await updateDoc(doc(db, MATCHES_COLL, matchId), myData);
            } catch(e) {}
        }

        function getPayload() {
            return {
                x: Math.round(playerMe.body.position.x),
                y: Math.round(playerMe.body.position.y),
                hp: playerMe.hp
            };
        }

        function handleNetworkUpdate(snap) {
            if (!snap.exists()) return;
            const data = snap.data();
            
            const opData = isHost ? data.player2 : data.player1;
            if (opData && playerOpponent) {
                playerOpponent.targetPos = { x: opData.x, y: opData.y };
                playerOpponent.hp = opData.hp;
                
                document.getElementById('p2-health').style.width = opData.hp + "%";
            }

            if (data.events) {
                data.events.forEach(ev => {
                    if (ev.shooter !== myUserId) {
                         createArrow(ev.x, ev.y, ev.angle, ev.power, false);
                    }
                });
                
                if (isHost && data.events.length > 0) {
                    updateDoc(doc(db, MATCHES_COLL, matchId), { events: [] });
                }
            }
        }

        async function pushEvent(ev) {
            await updateDoc(doc(db, MATCHES_COLL, matchId), {
                events: arrayUnion(ev)
            });
        }

        function takeDamage(amount) {
            playerMe.hp -= amount;
            document.getElementById('p1-health').style.width = Math.max(0, playerMe.hp) + "%";
            
            if (playerMe.hp <= 0) {
                gameOver(false);
            }
        }

        function gameOver(win) {
            gameActive = false;
            const overlay = document.getElementById('overlay-screen');
            overlay.classList.remove('opacity-0', 'pointer-events-none');
            overlay.innerHTML = `
                <h1 class="text-4xl md:text-6xl font-bold mb-4 ${win ? 'text-green-500' : 'text-red-500'}">${win ? 'Ø§Ù†ØªØµØ±Øª!' : 'Ø®Ø³Ø±Øª!'}</h1>
                <button onclick="location.reload()" class="px-8 py-4 bg-white text-black font-bold rounded-full hover:scale-105 transition shadow-xl">Ø§Ù„Ø¹Ø¨ Ù…Ø¬Ø¯Ø¯Ø§Ù‹</button>
            `;
        }

        init();
    </script>
</body>
</html>
